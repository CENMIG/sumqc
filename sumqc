#!/bin/bash

DIR="${BASH_SOURCE%/*}"
if [[ ! -d "$DIR"  ]]; then DIR="$PWD"; fi
source "$DIR/awk.sh"

usage() { 
    echo "Usage: $0 [<SR|LR>] [-t <SE|PE>] [-p <pb-rs2|pb-sequel|ont-ligation|ont-rapid|ont-1dsq>] [-i <*.fastq.gz|*[12].fastq.gz>] [-o <outputDir>] [-m] [-q <qcoption>] [-r]" 1>&2 ;  
}

help() {
    printf "SUMQC

    sumQC is a bioinformatics pipeline for cleaning 2nd and 3rd generation sequencing data. In addition, the program also gives to the user a summary table of the sequence data quality before and after the cleaning in the tab delimited text format, ready to be used for publication. The pipeline is written using NextFlow, a powerful and flexible workflow language that allows multiple tasks at different processing levels to be run parallely.

USAGE

    $0 [<SR|LR>] [-t <SE|PE>] [-p <pb-rs2|pb-sequel|ont-ligation|ont-rapid|ont-1dsq>] [-i <*.fastq.gz|*[12].fastq.gz>] [-o <outputDir>] [-m] [-q <qc options>] [-r]

    Short read workflow 

    $0 SR -t SE -i '*.fastq.gz' -o ./output -q 'AVGQUAL:30 MINLEN:70'

    $0 SR -t PE -i '*[12].fastq.gz' -o ./output -q 'AVGQUAL:30 MINLEN:70'

    Long read workflow 
    
    $0 LR -p pb-rs2 -i '*.fastq.gz' -o ./output -q '--min_length 10000'
    
DESCRIPTION

     sumQC contains two separate workflows; one for processing short-read data generated by 2nd generation sequencing technologies, and the other for processing and long read sequences generated by 3rd generation sequencers, utilising different sets of programs as shown below: 

                |  Workflow  |   QC   |   Cleaning  |
                 ------------ -------- ------------- 
                | Short read | FastQC | Trimmomatic |
                |  Long read | LongQC |    FiltLong |

    Cleaning options are use according to the program used in the workflow. Please refers to the program webpage for the full list of options.

    - Trimmomatic (http://www.usadellab.org/cms/?page=trimmomatic)
    - FiltLong (https://github.com/rrwick/Filtlong)

    sumQC takes a glob pattern of fastq file as input. If no pattern are specified the program will use default glob pattern according to the workflow and the type of read user specified. The program then run in the following steps in the pipeline. 

    1. Quality check before cleaning 
    2. Extracting data quality statistics before the cleaning.
    3. Cleaning the input fastq files.
    4. Quality check after the before cleaning.
    5. Extracting data quality statistic after the before cleaning.
    6. Making a table of data quality summary statistics. Summarise quality statistic into one table.

Full list of options for sumQC are as follows:

        -h      Print this help

        -i      Input fastq files, specified by using a glob pattern
        	    (e.g. *[12].fastq.gz)

        -o      Output directory

        -m      For paired-end read. Merge unpaired 
                forward and reverse reads into one file 
                after the cleaning process.

        -p      Sequencing platform for long read.
                (https://github.com/yfukasawa/LongQC)

                Platforms           Options
                ---------           -------
                RS-II               pb-rs2
                Sequel              pb-sequel
                ONT(1D ligation)    ont-ligation
                ONT(rapid)          ont-rapid

        -q      Cleaning options 

                default for short-read workflow:
                SLIDINGWINDOW:4:30 MINLEN:70

                default for long-read workflow:
                min_length 10000 --keep_percent 90
                
                Please refer to the program webpages for the syntax and the full list of
                options.

        -r      Resume from cache in work directoty.
                This is the same as:

                nextflow run main.nf -resume.

                (https://www.nextflow.io/docs/latest/cli.html?highlight=resume#run)\n\n" ;
}

if [ -z $1 ];
then
    usage;
fi
READS=$1;
shift;
#path to call main.nf script outside its directory
path=$(dirname $0)
while getopts "t:p:i:o:mrq:h" o;
do
    case $o in
        t) READTYPES=$OPTARG ;;
        p) PLATFORM=$OPTARG ;;
        i) INPUTS=$OPTARG ;;
        o) OUTPUTS=$OPTARG ;;
        m) MERGES=true ;;
        r) RESUME="-resume";;
        q) QCOPT=$OPTARG ;;
        h) help ;;
    esac
done;
shift $((OPTIND - 1))


if [ -n "$READS" ]
then
    case $READS in
        SR) main_script=main.nf 
            run=true
            if [ -n "$READTYPES" ]
            then
                case $READTYPES in 
                    SE) singleend="--SE=true"
                        filename="*.f[aq]*" ;;
                    PE) singleend="--SE=false"
                        filename="*{1,2}.f[aq]*" ;;
                    *) echo "must specify PE for paired-end or SE for single-end"
                       exit 65 ;;
                esac
            else
                echo "use -t to specify read type"
                exit 65
            fi
            ;;
        LR) main_script=main_longread.nf 
            filename="*.f[aq]*"
            run=true
            if [[ 'pb-rs2 pb-sequel ont-ligation ont-rapid ont-1dsq' =~ (^|[[:space:]])"$PLATFORM"($|[[:space:]]) ]]
            then
                platform="--platform='$PLATFORM'"
            else
                usage; 
                echo "Usage: must specify platform -p {pb-rs2, pb-sequel, ont-ligation, ont-rapid, ont-1dsq}"
                exit 65
            fi
            ;;
        QCsum) shift ;
            extract_fastqc $@ | column -t -s $'\t' ;;
        compare) calculate_percent $2 $3 $4 ;;
        -h) help ;;
        *) echo "Usage : must specify reads type, SR - short read, LR - long read";
           echo "./sumqc -h     for more info"
           exit 65 ;;
    esac
else
    echo "specify reads type, SR - short read, LR - long read" 
    exit 65 
fi;



if [ -n "$INPUTS" ]
then
    if [ -d "$INPUTS" ]
    then
        input="--input=${INPUTS}${filename}"
    else
        input="--input=$INPUTS"
    fi
else
    if [ "$READTYPES" == "SE" ]
    then
        input="--input=$PWD/*.f[aq]*"
    else 
        input="--input=$PWD/*[1,2].f[aq]*"
    fi
fi



if [ -n "$OUTPUTS" ]
then 
    output="--results=$OUTPUTS"
else
    output="--results=$PWD/results"
fi



if [ -n "$MERGES" ]
then 
    merge="--mergeUnpair=$MERGES"
else
    merge=''
fi



if [ -n "$QCOPT" ]
then 
    qcopt="$QCOPT"
elif [ "$READS" = "SR" ]
then

    qcopt="SLIDINGWINDOW:4:30 MINLEN:70"

elif [ "$READS" = "LR" ]
then
    qcopt="--min_length 10000 --keep_percent 90"
fi 

if [ $run ]
then
    echo "nextflow run $path/$main_script $platform $input $output $merge --qc_option=$qcopt" $RESUME $singleend
    nextflow run $path/$main_script $platform $input $output $merge --qc_options="$qcopt" $RESUME $singleend
fi
